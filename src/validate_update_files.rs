use crate::after_callback::return_usb_stick_mount_path;
use crate::utils::load_file_str;
use serde::Deserialize;
use std::path::Path;

/// Struct representing an update information
#[derive(Deserialize, Debug)]
struct Update {
    /// Name of the file
    file_name: String,
    /// Checksum of the file
    checksum: String,
}

/// Struct representing update information
#[derive(Deserialize, Debug)]
struct UpdateInfo {
    /// Struct representing an update information
    update: Update,
}

/// Function that parses update information from a JSON string
///
/// # Arguments
///
/// * `json` - a string that contains the JSON data to be parsed
///
/// # Return
///
/// Returns the parsed `UpdateInfo` struct, or a `serde_json::Error` in case of failure.
fn parse_update_info(json: &str) -> Result<UpdateInfo, serde_json::Error> {
    let update_info: UpdateInfo = serde_json::from_str(json)?;
    Ok(update_info)
}

/// Function that retrieves update information from a JSON file
///
/// # Return
///
/// Returns the `UpdateInfo` struct with the parsed update information.
fn get_json() -> UpdateInfo {
    let path = return_usb_stick_mount_path();
    let binding = Path::new(&path).join("start_update.json");
    let json_path = binding.as_os_str().to_str().unwrap();
    println!("Update json file detected on:{}", json_path);
    let result_json = parse_update_info(&load_file_str(json_path));
    let json = match result_json {
        Ok(json) => json,
        Err(_json) => todo!(),
    };
    println!("Parsed json view:{:#?}", json);
    return json;
}
/// Simple function that parses json and return patch to zip file
/// Do not require anything.
/// if no zip file found in json crashes update. Software can`t do anything about it
/// returns panic error  if no zip found
pub fn get_zip_path() -> String {
    let path = return_usb_stick_mount_path();
    let json = get_json();
    let binding = Path::new(&path).join(json.update.file_name);
    let binding = binding
        .as_os_str()
        .to_str()
        .expect("zip for update not found. code 125");
    return binding.to_string();
}
/// validates  is check_sum of file is equals to generated by rust sha256 module.
/// If yes returns true if not returns false
pub fn validate_check_sum(path: &str, checksum: String) -> bool {
    let bytes = std::fs::read(path).expect("cant read file. code 156");
    let hash = sha256::digest(&*bytes);
    println!(
        "Checksum of file:{}, is match with value in json:{}",
        path, checksum
    );
    return hash == checksum;
}
/// validates encrypted_zip with sha256 checkusm and returns bool if is true or false.
pub fn get_encrypted_zip_file_validation() -> bool {
    let path = return_usb_stick_mount_path();
    let json = get_json();
    let input_path = json.update.file_name.as_str();
    let checksum = json.update.checksum.as_str();
    let binding = Path::new(&path).join(input_path);
    let binding = binding.as_os_str().to_str().unwrap();
    let is_valid_checksum_update_zip = validate_check_sum(binding, checksum.to_string());
    if is_valid_checksum_update_zip {
        println!(
            "Checksum of {} had been matched :{} with {}",
            input_path, binding, checksum
        );
        return true;
    } else {
        panic!(
            "Fatal...invalid checksum for{},{},{}",
            input_path, binding, checksum
        );
    }
}
